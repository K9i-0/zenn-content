---
title: "Riverpod Generatorã«å¯¾å¿œã—ãŸãƒšãƒ¼ã‚¸ãƒ³ã‚°é«˜é€Ÿå®Ÿè£…ã®ä»•çµ„ã¿ã‚’ä½œã£ã¦ã¿ãŸ"
emoji: "ğŸ™"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["flutter", "riverpod", "riverpodgenerator"]
published: false
---

## ã¯ã˜ã‚ã«

ä»¥å‰Riverpodã§ãƒšãƒ¼ã‚¸ãƒ³ã‚°ã«å¯¾å¿œã—ãŸç”»é¢ã®æ±ç”¨å®Ÿè£…ã®è¨˜äº‹ã‚’æŠ•ç¨¿ã—ã¾ã—ãŸã€‚

https://zenn.dev/k9i/articles/b8c333e1bb8b9b

å½“æ™‚ã¯ä»Šã»ã©Riverpod GeneratorãŒåºƒã¾ã£ã¦ãªã‹ã£ãŸï¼ˆãŸã¶ã‚“â€¦ï¼‰ãŸã‚ã€Generatoréå¯¾å¿œã®å®Ÿè£…ã§ã—ãŸã€‚
ä»Šå›Generatorå¯¾å¿œç‰ˆã®å®Ÿè£…ã‚’è€ƒãˆã€ã¤ã„ã§ã«ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åŒ–ã‚‚ã—ã¦ã¿ãŸã®ã§ç¶šç·¨ã¨ã—ã¦ã“ã®è¨˜äº‹ã§ç´¹ä»‹ã—ã¾ã™ğŸ‘

:::message
ã“ã®è¨˜äº‹ãŠã‚ˆã³ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯Riverpod Generatorã®ä½¿ã„æ–¹ã‚’çŸ¥ã£ã¦ã‚‹å‰æã§ã™ã€‚
:::

## ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ç´¹ä»‹

riverpod_paging_utilsã¨ã„ã†åå‰ã«ã—ã¾ã—ãŸã€‚

https://pub.dev/packages/riverpod_paging_utils

### ä½¿ã„æ–¹
ä»Šå›ã¯ã‚«ãƒ¼ã‚½ãƒ«ãƒ™ãƒ¼ã‚¹ã®ãƒšãƒ¼ã‚¸ãƒ³ã‚°ã‚’ã—ã¾ã™ã€‚

ã¾ã™ã¯Providerã‚’å®šç¾©ã—ã¾ã™ã€‚
ã„ã¤ã‚‚ã®ã‚¯ãƒ©ã‚¹ãƒ™ãƒ¼ã‚¹ã®Providerã«CursorPagingNotifierMixinã‚’è¿½è¨˜ã—ã¾ã™ã€‚
ãã†ã™ã‚‹ã¨fetchã¨ã„ã†ãƒ¡ã‚½ãƒƒãƒ‰ã®overrideã‚’è¦æ±‚ã•ã‚Œã‚‹ã®ã§ã€å¼•æ•°ã®cursorã‚’ä½¿ã£ã¦CursorPagingDataã‚’è¿”ã™å®Ÿè£…ã‚’ã—ã¾ã™ã€‚
ã¾ãŸæœ€åˆã®ãƒšãƒ¼ã‚¸å–å¾—ã¯buildã§è¡Œã†ã®ã§ã€watchã—ãŸã„Providerã¨ã‹ãŒãªã‘ã‚Œã°å…ˆã»ã©ã®fetchã‚’å‘¼ã³ã¾ã™ã€‚

```dart
// 1. CursorPagingNotifierMixinã‚’with
@riverpod
class SampleNotifier extends _$SampleNotifier with CursorPagingNotifierMixin {

  // 3. fetchã‚’ä½¿ã†ã¨æ¥½
  @override
  Future<CursorPagingData<SampleItem>> build() => fetch(cursor: null);

  // 2. fetchã‚’override
  @override
  Future<CursorPagingData<SampleItem>> fetch({
    required String? cursor,
  }) async {
    final repository = ref.read(sampleRepositoryProvider);
    final (items, nextCursor) = await repository.getByCursor(cursor);
    final hasMore = nextCursor != null && nextCursor.isNotEmpty;

    return CursorPagingData(
      items: items,
      hasMore: hasMore,
      nextCursor: nextCursor,
    );
  }
}
```

æ¬¡ã«ç”»é¢ã®å®Ÿè£…ã§ã™ã€‚
PagingHelperViewã¨ã„ã†Widgetã‚’ä½¿ã„ã¾ã™ã€‚
providerã«å…ˆã»ã©å®šç¾©ã—ãŸsampleNotifierProviderã‚’æ¸¡ã—ã¾ã™ã€‚
contentBuilderã¯data(è¡¨ç¤ºç”¨ã®ãƒ‡ãƒ¼ã‚¿)ã¨endItemView(ãƒšãƒ¼ã‚¸ãƒ³ã‚°å‡¦ç†ä¸­ã«è¡¨ç¤ºã•ã‚Œã‚‹æœ«å°¾ã®Widget)ã‚’å¼•æ•°ã«Widgetã‚’è¿”ã™builderã§ã™ã€‚ListViewãªã©ã‚’è¿”ã™ã‚ˆã†ã«ã—ã¾ã™ã€‚

```dart
class SamplePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Sample Page'),
      ),
      body: PagingHelperView(
        provider: sampleNotifierProvider,
        contentBuilder: (data, endItemView) => ListView.builder(
          itemCount: data.items.length + (endItemView != null ? 1 : 0),
          itemBuilder: (context, index) {
            if (endItemView != null && index == data.items.length) {
              return endItemView;
            }
            return ListTile(
              title: Text(data.items[index].name),
              subtitle: Text(data.items[index].id),
            );
          },
        ),
      ),
    );
  }
}
```

:::message
Repositoryãªã©ã‚‚å«ã‚ãŸå®Œå…¨ãªå®Ÿè£…ã¯exampleã‚’ã”è¦§ãã ã•ã„ğŸ™
https://github.com/K9i-0/riverpod_paging_utils/tree/main/example/lib
:::

ã“ã“ã¾ã§ã“ã®ã‚ˆã†ãªç”»é¢ãŒä½œã‚Œã¾ã™ã€‚

![](/images/riverpod_paging_utils.gif =500x)

æ©Ÿèƒ½çš„ã«ã¯
- 1ãƒšãƒ¼ã‚¸ç›®
  - ãƒ‡ãƒ¼ã‚¿å–å¾—ã«æˆåŠŸã—ãŸã‚‰ãƒªã‚¹ãƒˆè¡¨ç¤º
  - èª­ã¿è¾¼ã¿ä¸­ã¯å…¨é¢ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤º
  - ã‚¨ãƒ©ãƒ¼æ™‚ã¯å…¨é¢ã‚¨ãƒ©ãƒ¼ç”»é¢ï¼‹ã‚¹ãƒŠãƒƒã‚¯ãƒãƒ¼ã§ã‚¨ãƒ©ãƒ¼ã‚’ä¼ãˆã‚‹
  - å…¨é¢ã‚¨ãƒ©ãƒ¼ç”»é¢ã«ã¯ãƒªãƒˆãƒ©ã‚¤ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤ºã™ã‚‹
- 2ãƒšãƒ¼ã‚¸ç›®ä»¥é™
  - ãƒªã‚¹ãƒˆã®æœ€ä¸‹éƒ¨ã«åˆ°é”æ™‚ã«èª­ã¿è¾¼ã¿é–‹å§‹
  - ãƒ‡ãƒ¼ã‚¿å–å¾—ã«æˆåŠŸã—ãŸã‚‰ãƒªã‚¹ãƒˆè¡¨ç¤º
  - èª­ã¿è¾¼ã¿ä¸­ã¯æœ€ä¸‹éƒ¨ã«ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤º
  - ã‚¨ãƒ©ãƒ¼æ™‚ã¯å–å¾—æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿ã®è¡¨ç¤ºã‚’ç¶­æŒï¼‹ã‚¹ãƒŠãƒƒã‚¯ãƒãƒ¼ã§ã‚¨ãƒ©ãƒ¼ã‚’ä¼ãˆã‚‹
- ãã®ä»–
  - Pull to Refreshã§æœ€åˆã®ãƒšãƒ¼ã‚¸ã‹ã‚‰èª­ã¿ç›´ã›ã‚‹
  - Pull to Refreshä¸­ã¯å…ƒã®è¡¨ç¤ºã‚’ç¶­æŒã™ã‚‹
ã¨ãªã£ã¦ã¾ã™ã€‚

## ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ä¸­èº«

ä¸»ã«3ç¨®é¡ã®ã‚¯ãƒ©ã‚¹(ã¨mixin)ã‹ã‚‰æˆã‚Šç«‹ã£ã¦ã¾ã™ã€‚

### ã€‡ã€‡PagingData
Pagingç”¨ã®ãƒ‡ãƒ¼ã‚¿ãŒå…¥ã‚‹ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ã€‡ã€‡ã«ã¯Pageã€Offsetã€Cursorã®3ç¨®é¡ãŒã‚ã‚Šã¾ã™ã€‚
PagingDataãŒå…±é€šã§itemsã¨hasMoreã‚’æŒã¡ã¾ã™ã€‚CursorPagingDataãªã©ã¯è¿½åŠ ã§nextCursorãªã©ãƒšãƒ¼ã‚¸ãƒ³ã‚°æ–¹å¼ã«å¿œã˜ãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã¡ã¾ã™ã€‚
ç¾çŠ¶freezedã‚’ä½¿ã£ã¦ã„ã¾ã™ãŒã€freezedã®ä¾å­˜ã‚’ãªãã—ãŸæ–¹ãŒã„ã„ã‹ãªã€œã¨æ€ã£ã¦ã„ã¾ã™ã€‚

```dart
abstract class PagingData<T> {
  List<T> get items;
  bool get hasMore;
}

@freezed
class CursorPagingData<T> with _$CursorPagingData<T> implements PagingData<T> {
  const factory CursorPagingData({
    required List<T> items,
    required bool hasMore,
    required String? nextCursor,
  }) = _CursorPagingData;
}
```

### ã€‡ã€‡PagingNotifierMixin
Providerã®å®šç¾©ã«ä½¿ã†Mixinã§ã™ã€‚loadNextãŒãƒ¡ã‚¤ãƒ³ã§ã€ã“ã‚Œã¯2ãƒšãƒ¼ã‚¸ç›®ä»¥é™ã®å–å¾—ã§ä½¿ã„ã¾ã™ã€‚
ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã€ã‚¨ãƒ©ãƒ¼ãªã©ã‚’ã‚ˆã—ãªã«ã‚„ã£ã¦ãã‚Œã‚‹ã‚ˆã†ã«ã—ã¦ã¾ã™ã€‚
fetchã®å¼•æ•°ãŒãƒšãƒ¼ã‚¸ãƒ³ã‚°æ–¹å¼ã§å¤‰ã‚ã‚‹ã®ã§ã€ãƒšãƒ¼ã‚¸ãƒ³ã‚°æ–¹å¼ã”ã¨ã«Mixinã‚’å®Ÿè£…ã—ã¦ã¾ã™ã€‚

```dart
mixin CursorPagingNotifierMixin<T>
    on AutoDisposeAsyncNotifier<CursorPagingData<T>> {
  Future<CursorPagingData<T>> fetch({required String? cursor});

  Future<void> loadNext() async {
    final value = state.valueOrNull;
    if (value == null || state.hasError) {
      return;
    }

    if (value.hasMore) {
      state = AsyncLoading<CursorPagingData<T>>().copyWithPrevious(state);

      state = await state.guardPreservingPreviousOnError(
        () async {
          final next = await fetch(cursor: value.nextCursor);

          return value.copyWith(
            items: [...value.items, ...next.items],
            nextCursor: next.nextCursor,
            hasMore: next.hasMore,
          );
        },
      );
    }
  }

  void forceRefresh() {
    state = AsyncLoading<CursorPagingData<T>>();
    ref.invalidateSelf();
  }
}

extension _AsyncValueX<T> on AsyncValue<T> {
  Future<AsyncValue<T>> guardPreservingPreviousOnError(
    Future<T> Function() future,
  ) async {
    try {
      return AsyncValue.data(await future());
    } on Exception catch (err, stack) {
      return AsyncValue<T>.error(err, stack).copyWithPrevious(this);
    }
  }
}

```


### PagingHelperView
ãƒšãƒ¼ã‚¸ãƒ³ã‚°ç”»é¢ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®Widgetã§ã™ã€‚
åŸºæœ¬providerã‚’æ¸¡ã™ã ã‘ã§ã‚ˆã—ãªã«ã‚„ã£ã¦ãã‚Œã¾ã™ã€‚
æœ€åˆã®assertã¯Mixinã‚’ã¡ã‚ƒã‚“ã¨å®Ÿè£…ã—ã¦ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ã—ã¦ã¾ã™ã€‚Genericsã§ã§ããªã„ã‹èª¿ã¹ãŸã‘ã©ã‚ã‹ã‚‰ãªã‹ã£ãŸğŸ¥º
listenéƒ¨åˆ†ã¯ä¸»ã«2ãƒšãƒ¼ã‚¸ç›®ä»¥é™ã®ã‚¨ãƒ©ãƒ¼ã§dataã‚’è¡¨ç¤ºã—ã¤ã¤ã‚¹ãƒŠãƒƒã‚¯ãƒãƒ¼ã§ã‚¨ãƒ©ãƒ¼ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚
_EndItemViewã¯2ãƒšãƒ¼ã‚¸ç›®ä»¥é™ã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§è¡¨ç¤ºã•ã‚Œã‚‹ãã‚‹ãã‚‹ã§ã™ã€‚VisibilityDetectorã§onScrollEndã‚’å‘¼ã¶ã‚ˆã†ã«ã—ã¦ãŠã‚Šã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã§Mixinã«å¿œã˜ãŸloadNextã‚’èª­ã‚“ã§ã„ã¾ã™ã€‚
ç¾çŠ¶ã‚¨ãƒ©ãƒ¼ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãŒã§ããªã„ã®ã§æ”¹è‰¯ã—ãŸã„ğŸ˜…


```dart
class PagingHelperView<N extends AutoDisposeAsyncNotifier<D>,
    D extends PagingData<I>, I> extends ConsumerWidget {
  const PagingHelperView({
    required this.provider,
    required this.contentBuilder,
    super.key,
  });

  final AutoDisposeAsyncNotifierProvider<N, D> provider;

  final Widget Function(D data, Widget? endItemView) contentBuilder;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    assert(
      ref.read(provider.notifier) is PagePagingNotifierMixin ||
          ref.read(provider.notifier) is OffsetPagingNotifierMixin ||
          ref.read(provider.notifier) is CursorPagingNotifierMixin,
      'The notifier must implement PagePagingNotifierMixin, OffsetPagingNotifierMixin, or CursorPagingNotifierMixin',
    );

    ref.listen(provider, (_, state) {
      if (!state.isLoading && state.hasError) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              state.error!.toString(),
            ),
          ),
        );
      }
    });

    return ref.watch(provider).whenIgnorableError(
          data: (data, {required hasError}) {
            return RefreshIndicator(
              onRefresh: () => ref.refresh(provider.future),
              child: contentBuilder(
                data,
                data.hasMore && !hasError
                    ? _EndItemView(
                        onScrollEnd: () {
                          switch (ref.read(provider.notifier)) {
                            case (final PagePagingNotifierMixin pageNotifier):
                              pageNotifier.loadNext();
                            case (final OffsetPagingNotifierMixin
                                  offsetNotifier):
                              offsetNotifier.loadNext();
                            case (final CursorPagingNotifierMixin
                                  cursorNotifier):
                              cursorNotifier.loadNext();
                          }
                        },
                      )
                    : null,
              ),
            );
          },
          loading: () => const Center(
            child: CircularProgressIndicator(),
          ),
          error: (e, st) => Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                IconButton(
                  onPressed: () {
                    switch (ref.read(provider.notifier)) {
                      case (final PagePagingNotifierMixin pageNotifier):
                        pageNotifier.forceRefresh();
                      case (final OffsetPagingNotifierMixin offsetNotifier):
                        offsetNotifier.forceRefresh();
                      case (final CursorPagingNotifierMixin cursorNotifier):
                        cursorNotifier.forceRefresh();
                    }
                  },
                  icon: const Icon(Icons.refresh),
                ),
                Text(e.toString()),
              ],
            ),
          ),
          skipErrorOnHasValue: true,
        );
  }
}

class _EndItemView extends StatelessWidget {
  const _EndItemView({
    required this.onScrollEnd,
  });
  final VoidCallback onScrollEnd;

  @override
  Widget build(BuildContext context) {
    return VisibilityDetector(
      key: key ?? const Key('EndItem'),
      onVisibilityChanged: (info) {
        if (info.visibleFraction > 0.1) {
          onScrollEnd();
        }
      },
      child: const Center(
        child: Padding(
          padding: EdgeInsets.all(16),
          child: CircularProgressIndicator(),
        ),
      ),
    );
  }
}

extension _AsyncValueX<T> on AsyncValue<T> {
  R whenIgnorableError<R>({
    required R Function(T data, {required bool hasError}) data,
    required R Function(Object error, StackTrace stackTrace) error,
    required R Function() loading,
    bool skipLoadingOnReload = false,
    bool skipLoadingOnRefresh = true,
    bool skipError = false,
    bool skipErrorOnHasValue = false,
  }) {
    if (skipErrorOnHasValue) {
      if (hasValue && hasError) {
        return data(requireValue, hasError: true);
      }
    }

    return when(
      skipLoadingOnReload: skipLoadingOnReload,
      skipLoadingOnRefresh: skipLoadingOnRefresh,
      skipError: skipError,
      data: (d) => data(d, hasError: hasError),
      error: error,
      loading: loading,
    );
  }
}
```


## ã¾ã¨ã‚
riverpod_paging_utilsã‚’ç´¹ä»‹ã—ã¾ã—ãŸã€‚
ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚„ã‚¨ãƒ©ãƒ¼ç”»é¢ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãªã©ã§ãã‚‹ã‚ˆã†ã«ã‚¢ãƒ—ãƒ‡ã—ã¦ã„ããŸã„ã¨æ€ã£ã¦ã„ã¾ã™ã€‚
æ°—ãŒå‘ã„ãŸã‚‰ãƒªãƒã‚¸ãƒˆãƒªã«â­ã‚‚ã‚‰ãˆã‚‹ã¨å¬‰ã—ã„ã§ã™ã€œ

ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ãã®ã¾ã¾ä½¿ã†ã»ã‹ã€ä¼¼ãŸã‚ˆã†ãªã“ã¨ã‚’ã—ãŸã„æ™‚ã®å‚è€ƒã«ã—ã¦ãã ã•ã„ğŸ‘