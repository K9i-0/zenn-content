---
title: "Riverpodã‚’ä½¿ã£ãŸæ±ç”¨ãƒšãƒ¼ã‚¸ãƒ³ã‚°å®Ÿè£…ã‚’ä½œã£ã¦ã¿ã‚‹"
emoji: "ğŸ™"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Flutter", "Riverpod"]
published: false
---
# å‰æ
ãƒšãƒ¼ã‚¸ãƒ³ã‚°å¯¾å¿œç”»é¢ã‚’ç°¡å˜ã«å®Ÿè£…ã™ã‚‹ãŸã‚ã®æ±ç”¨å®Ÿè£…ã‚’ä½œã‚ŠãŸã„

![](/images/2023-02-01_09.32.34.gif =500x)

## ç”»é¢ä»•æ§˜
ä»¥ä¸‹ã®ã‚ˆã†ãªä»•æ§˜
- 1ãƒšãƒ¼ã‚¸ç›®
  - ãƒ‡ãƒ¼ã‚¿å–å¾—ã«æˆåŠŸã—ãŸã‚‰ãƒªã‚¹ãƒˆè¡¨ç¤º
  - èª­ã¿è¾¼ã¿ä¸­ã¯å…¨é¢ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤º
  - ã‚¨ãƒ©ãƒ¼æ™‚ã¯å…¨é¢ã‚¨ãƒ©ãƒ¼ç”»é¢ï¼‹ã‚¹ãƒŠãƒƒã‚¯ãƒãƒ¼ã§ã‚¨ãƒ©ãƒ¼ã‚’ä¼ãˆã‚‹
  - å…¨é¢ã‚¨ãƒ©ãƒ¼ç”»é¢ã«ã¯ãƒªãƒˆãƒ©ã‚¤ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤ºã™ã‚‹
- 2ãƒšãƒ¼ã‚¸ç›®ä»¥é™
  - ãƒªã‚¹ãƒˆã®æœ€ä¸‹éƒ¨ã«åˆ°é”æ™‚ã«èª­ã¿è¾¼ã¿é–‹å§‹
  - ãƒ‡ãƒ¼ã‚¿å–å¾—ã«æˆåŠŸã—ãŸã‚‰ãƒªã‚¹ãƒˆè¡¨ç¤º
  - èª­ã¿è¾¼ã¿ä¸­ã¯æœ€ä¸‹éƒ¨ã«ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤º
  - ã‚¨ãƒ©ãƒ¼æ™‚ã¯å–å¾—æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿ã®è¡¨ç¤ºã‚’ç¶­æŒï¼‹ã‚¹ãƒŠãƒƒã‚¯ãƒãƒ¼ã§ã‚¨ãƒ©ãƒ¼ã‚’ä¼ãˆã‚‹
- ãã®ä»–
  - Pull to Refreshã§æœ€åˆã®ãƒšãƒ¼ã‚¸ã‹ã‚‰èª­ã¿ç›´ã›ã‚‹
  - Pull to Refreshä¸­ã¯å…ƒã®è¡¨ç¤ºã‚’ç¶­æŒã™ã‚‹


## æŠ€è¡“é¢
- Riverpodã®AsyncValueã«ä¹—ã£ã‹ã‚‹
- ä»¥ä¸‹ã®ä¸‰ã¤ã®ãƒšãƒ¼ã‚¸ãƒ³ã‚°æ–¹å¼ã«å¯¾å¿œã•ã›ã‚‹
  - Page based paging
  - Offset based paging
  - Cursor based paging
- ãƒ‡ãƒ¼ã‚¿ä¿æŒç”¨ã‚¯ãƒ©ã‚¹ã«freezedã‚’ä½¿ã†
# æ±ç”¨ã‚¯ãƒ©ã‚¹ã®æº–å‚™
ä»¥ä¸‹ã®4ã¤ã‚’å®Ÿè£…ã—ã¦ã„ã
- ãƒ‡ãƒ¼ã‚¿ä¿æŒç”¨åŸºåº•ã‚¯ãƒ©ã‚¹
- Notifierç”¨åŸºåº•ã‚¯ãƒ©ã‚¹
- æ±ç”¨ãƒšãƒ¼ã‚¸ãƒ³ã‚°Widget
- AsyncValueæ‹¡å¼µ
## ãƒ‡ãƒ¼ã‚¿ä¿æŒç”¨åŸºåº•ã‚¯ãƒ©ã‚¹
```dart:paging_data.dart
// ignore: unused_import, directives_ordering
import 'package:freezed_annotation/freezed_annotation.dart';

part 'paging_data.freezed.dart';

/// PagingDataã®itemã®åŸºåº•ã‚¯ãƒ©ã‚¹
/// [id]ã‚’æŒã¤ã“ã¨ã‚’å¼·åˆ¶ã™ã‚‹
abstract class PagingDataItem {
  String get id;
}

/// æ±ç”¨ãƒšãƒ¼ã‚¸ãƒ³ã‚°Widgetã‚’ä½¿ã†ãŸã‚ã®åŸºåº•ã‚¯ãƒ©ã‚¹
abstract class PagingData<T extends PagingDataItem> {
  List<T> get items;
  bool get hasMore;
}

@freezed
class PageBasedPagingData<T extends PagingDataItem>
    with _$PageBasedPagingData<T>
    implements PagingData<T> {
  const PageBasedPagingData._();
  const factory PageBasedPagingData({
    required List<T> items,
    required int page,
    required bool hasMore,
  }) = _PageBasedPagingData<T>;
}
```
## Notifierç”¨åŸºåº•ã‚¯ãƒ©ã‚¹
```dart:paging_async_notifier.dart
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:riverpod_paging_sample/async_value_extension.dart';
import 'package:riverpod_paging_sample/paging_data.dart';

abstract class PagingAsyncNotifier<T extends PagingData>
    extends AutoDisposeAsyncNotifier<T> {
  Future<void> loadNext();

  // çŠ¶æ…‹ã‚’ç ´æ£„ã—ã¦å†èª­ã¿è¾¼ã¿ã™ã‚‹
  void forceRefresh() {
    state = AsyncLoading<T>();
    ref.invalidateSelf();
  }
}

/// PageBasedPagingã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®Notifier
/// [build]ã¨[fetchNext]ã‚’overrideã™ã‚‹ã“ã¨ã§ã€ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚„ã‚¨ãƒ©ãƒ¼ãŒå‹æ‰‹ã«å‡¦ç†ã•ã‚Œã‚‹
abstract class PageBasedPagingAsyncNotifier<T extends PagingDataItem>
    extends PagingAsyncNotifier<PageBasedPagingData<T>> {
  /// 2ãƒšãƒ¼ã‚¸ç›®ä»¥é™ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
  /// [PageBasedPagingAsyncNotifier]ã‚’ç¶™æ‰¿ã—ãŸã‚¯ãƒ©ã‚¹å†…ï¼ˆã‚‚ã£ã¨è¨€ãˆã°[loadNext]ï¼‰ã‹ã‚‰ã—ã‹å‘¼ã°ãªã„æƒ³å®š
  Future<PageBasedPagingData<T>> fetchNext(int page);

  /// 2ãƒšãƒ¼ã‚¸ç›®ä»¥é™ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹
  /// åŸºæœ¬çš„ã«overrideã™ã‚‹å¿…è¦ã¯ãªã„
  @override
  Future<void> loadNext() async {
    // ãƒ‡ãƒ¼ã‚¿ãŒãªã„æ™‚ã¯ä½•ã‚‚ã—ãªã„
    final value = state.valueOrNull;
    if (value == null) {
      return;
    }
    // ã‚¨ãƒ©ãƒ¼ãŒã‚ã‚‹æ™‚ã¯ä½•ã‚‚ã—ãªã„
    if (state.hasError) {
      return;
    }

    if (value.hasMore) {
      state = AsyncLoading<PageBasedPagingData<T>>().copyWithPrevious(state);

      state = await state.guardPlus(
        () async {
          final next = await fetchNext(value.page + 1);

          return value.copyWith(
            items: [...value.items, ...next.items],
            page: value.page + 1,
            hasMore: next.hasMore,
          );
        },
      );
    }
  }
}
```
## æ±ç”¨ãƒšãƒ¼ã‚¸ãƒ³ã‚°Widget
```dart:common_paging_view.dart
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:riverpod_paging_sample/async_value_extension.dart';
import 'package:riverpod_paging_sample/paging_async_notifier.dart';
import 'package:riverpod_paging_sample/paging_data.dart';
import 'package:visibility_detector/visibility_detector.dart';

/// ãƒšãƒ¼ã‚¸ãƒ³ã‚°ã®ãŸã‚ã®æ±ç”¨Widget
///
/// ä¸»ãªæ©Ÿèƒ½
/// 1. ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯ã€[contentBuilder]ã§ä½œã£ãŸWidgetã‚’è¡¨ç¤ºã™ã‚‹
/// 2. 1ãƒšãƒ¼ã‚¸ã®èª­ã¿è¾¼ã¿ä¸­ã¯ã€CircularProgressIndicatorã‚’è¡¨ç¤ºã™ã‚‹
/// 3. 1ãƒšãƒ¼ã‚¸ç›®ã®ã‚¨ãƒ©ãƒ¼æ™‚ã¯ã€ã‚¨ãƒ©ãƒ¼Widgetã‚’è¡¨ç¤ºã™ã‚‹
/// 4. ã‚¨ãƒ©ãƒ¼æ™‚ã«ã‚¹ãƒŠãƒƒã‚¯ãƒãƒ¼ã§ã‚¨ãƒ©ãƒ¼ã‚’è¡¨ç¤ºã™ã‚‹
/// 5. æœ€å¾Œã®ã‚¢ã‚¤ãƒ†ãƒ ãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰ã€æ¬¡ã®ãƒšãƒ¼ã‚¸ã‚’èª­ã¿è¾¼ã‚€
/// 6. Pull to Refreshã«å¯¾å¿œã™ã‚‹
class CommonPagingView<
    N extends PagingAsyncNotifier<D>,
    D extends PagingData<I>,
    I extends PagingDataItem> extends HookConsumerWidget {
  /// [PagingAsyncNotifier]ã‚’å®Ÿè£…ã—ãŸã‚¯ãƒ©ã‚¹ã®Providerã‚’æŒ‡å®šã™ã‚‹
  final AutoDisposeAsyncNotifierProvider<N, D> provider;

  /// ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã«è¡¨ç¤ºã™ã‚‹Widgetã‚’è¿”ã™é–¢æ•°ã‚’æŒ‡å®šã™ã‚‹
  /// [endItem]ã¯æœ€å¾Œã«è¡¨ç¤ºã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ãŒè¡¨ç¤ºã•ã‚ŒãŸã“ã¨ã‚’æ¤œçŸ¥ã™ã‚‹ãŸã‚ã®Widgetã§ã€non nullã®æ™‚ã«ãƒªã‚¹ãƒˆã®æœ€å¾Œã«è¡¨ç¤ºã™ã‚‹
  final Widget Function(D data, Widget? endItem) contentBuilder;
  const CommonPagingView({
    required this.provider,
    required this.contentBuilder,
    super.key,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // ã‚¹ãƒŠãƒƒã‚¯ãƒãƒ¼ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
    ref.listen(provider, (_, state) {
      state.showSnackbarOnError(context);
    });

    return ref.watch(provider).whenPlus(
          data: (data, hasError) {
            return RefreshIndicator(
              onRefresh: () => ref.refresh(provider.future),
              child: contentBuilder(
                data,
                // æ¬¡ã®ãƒšãƒ¼ã‚¸ãŒã‚ã‚Šã€ã‹ã¤ã‚¨ãƒ©ãƒ¼ãŒãªã„å ´åˆã«ã€æœ€å¾Œã®è¦ç´ ã«é”ã—ãŸã“ã¨ã‚’æ¤œçŸ¥ã™ã‚‹ãŸã‚ã®Widgetã‚’è¡¨ç¤ºã™ã‚‹
                data.hasMore && !hasError
                    ? EndItem(
                        onScrollEnd: () =>
                            ref.read(provider.notifier).loadNext(),
                      )
                    : null,
              ),
            );
          },
          // ï¼‘ãƒšãƒ¼ã‚¸ç›®ã®ãƒ­ãƒ¼ãƒ‰ä¸­
          loading: () => const Center(
            child: CircularProgressIndicator(),
          ),
          // ï¼‘ãƒšãƒ¼ã‚¸ç›®ã®ã‚¨ãƒ©ãƒ¼
          error: (e, st) => Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                IconButton(
                  onPressed: () => ref.read(provider.notifier).forceRefresh(),
                  icon: const Icon(Icons.refresh),
                ),
                Text(e.toString()),
              ],
            ),
          ),
          // 2ãƒšãƒ¼ã‚¸ç›®ä»¥é™ã®ã‚¨ãƒ©ãƒ¼ã§ãƒ‡ãƒ¼ã‚¿ã‚’å„ªå…ˆã™ã‚‹
          skipErrorOnHasValue: true,
        );
  }
}

class EndItem extends StatelessWidget {
  final VoidCallback onScrollEnd;
  const EndItem({
    super.key,
    required this.onScrollEnd,
  });

  @override
  Widget build(BuildContext context) {
    return VisibilityDetector(
      key: key ?? const Key('EndItem'),
      onVisibilityChanged: (info) {
        if (info.visibleFraction > 0.1) {
          onScrollEnd();
        }
      },
      child: const Center(
        child: Padding(
          padding: EdgeInsets.all(16),
          child: CircularProgressIndicator(),
        ),
      ),
    );
  }
}
```
## AsyncValueæ‹¡å¼µ
```dart:async_value_extension.dart
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

extension AsyncValueX<T> on AsyncValue<T> {
  /// guardé–¢æ•°ã®æ‹¡å¼µç‰ˆ
  /// ä¾‹å¤–æ™‚ã«å‰å›ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒãŸã›ã¦ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™
  Future<AsyncValue<T>> guardPlus(Future<T> Function() future) async {
    try {
      return AsyncValue.data(await future());
    } catch (err, stack) {
      // å‰å›ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒãŸã›ã¦ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™
      return AsyncValue<T>.error(err, stack).copyWithPrevious(this);
    }
  }

  /// whené–¢æ•°ã®æ‹¡å¼µç‰ˆ
  ///
  /// [skipErrorOnHasValue]ãŒtrueã®æ™‚ã¯ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã®ã‚¨ãƒ©ãƒ¼ã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹
  /// ãƒšãƒ¼ã‚¸ãƒ³ã‚°ã®2ãƒšãƒ¼ã‚¸ç›®ä»¥é™ã§ã‚¨ãƒ©ãƒ¼æ™‚ã«ã€å–å¾—ãšã¿ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤ºã™ã‚‹å ´åˆãªã©ã«ä½¿ç”¨ã™ã‚‹
  R whenPlus<R>({
    bool skipLoadingOnReload = false,
    bool skipLoadingOnRefresh = true,
    bool skipError = false,
    bool skipErrorOnHasValue = false,
    required R Function(T data, bool hasError) data,
    required R Function(Object error, StackTrace stackTrace) error,
    required R Function() loading,
  }) {
    if (skipErrorOnHasValue) {
      if (hasValue && hasError) {
        return data(requireValue, true);
      }
    }

    return when(
      skipLoadingOnReload: skipLoadingOnReload,
      skipLoadingOnRefresh: skipLoadingOnRefresh,
      skipError: skipError,
      data: (d) => data(d, hasError),
      error: error,
      loading: loading,
    );
  }

  /// ã‚¨ãƒ©ãƒ¼æ™‚ã«ã‚¹ãƒŠãƒƒã‚¯ãƒãƒ¼ã‚’è¡¨ç¤ºã™ã‚‹
  void showSnackbarOnError(
    BuildContext context, {
    String defaultMessage = "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ",
  }) {
    if (!isLoading && hasError) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            error!.toString(),
          ),
        ),
      );
    }
  }
}
```
# æ±ç”¨ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã£ã¦ã¿ã‚‹